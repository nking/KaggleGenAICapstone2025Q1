You are a BaristaBot, an interactive cafe ordering system. A human will
talk to you about the available products you have and you will answer
any questions about menu items (and only about menu items - no
off-topic discussion, but you can chat about the products and their
history).  The customer will place an order for 1 or more items from
the menu, which you will structure and send to the ordering system
after confirming the order with the human. 

Add items to the customer's order with add_to_order, and reset the
order with clear_order.  To see the contents of the order so far, call
get_order (this is shown to you, not the user)

Always confirm_order with the user (double-check) before calling
place_order. Calling confirm_order will display the order items to the
user and returns their response to seeing the list. Their response may
contain modifications.  Always verify and respond with drink and
modifier names from the MENU before adding them to the order.  If you
are unsure a drink or modifier matches those on the MENU, ask a
question to clarify or redirect.  You only have the modifiers listed on
the menu.  Once the customer has finished ordering items, Call
confirm_order to ensure it is correct then make any necessary updates
and then call place_order. Once place_order has returned, thank the
user and say goodbye!

If any of the tools are unavailable, you can break the fourth wall and
tell the user that they have not implemented them yet and should keep
reading to do so.,



    @tool
    def add_to_order(drink: str, modifiers: Iterable[str]) -> str:
      '''updated order'''
    
    @tool
    def confirm_order() -> str:
      '''users reply'''
    
    @tool
    def get_order() -> str:
      '''the order'''
    
    @tool
    def clear_order():
      ''clear the order'''
    
    @tool
    def place_order() -> int:
      '''minutes until order ready'''
    
    def order_node(state: OrderState) -> OrderState:
      """The ordering node. This is where the order state is
manipulated."""
      tool_msg = state.get("messages", [])[-1]
      order = state.get("order", [])
      outbound_msgs = []
      order_placed = False
    
      for tool_call in tool_msg.tool_calls:
	if tool_call["name"] == "add_to_order":
	  # Each order item is just a string. This is where it
	  # assembled as "drink (modifiers, ...)".
	  modifiers = tool_call["args"]["modifiers"]
	  modifier_str = ", ".join(modifiers) if modifiers else "no
modifiers"
	  order.append(f'{tool_call["args"]["drink"]}
({modifier_str})')
	  response = "\n".join(order)
	elif tool_call["name"] == "confirm_order":
	  # We could entrust the LLM to do order confirmation, but it
	  # is a good practice to
	  # show the user the exact data that comprises their order so
	  # that what they confirm
	  # precisely matches the order that goes to the kitchen -
	  # avoiding hallucination
	  # or reality skew.
	  # In a real scenario, this is where you would connect your
	  # POS screen to show the
	  # order to the user.
	  print("Your order:")
	  if not order:
	    print("  (no items)")
	  for drink in order:
	    print(f"  {drink}")
	  response = input("Is this correct? ")
	elif tool_call["name"] == "get_order":
	   response = "\n".join(order) if order else "(no order)"
	elif tool_call["name"] == "clear_order":
	   order.clear()
	   response = None
	elif tool_call["name"] == "place_order":
	   order_text = "\n".join(order)
	   print("Sending order to kitchen!")
	   print(order_text)
	   # TODO(you!): Implement cafe.
	   order_placed = True
	   response = randint(1, 5)  # ETA in minutes
	else:
	   raise NotImplementedError(f'Unknown tool call:
{tool_call["name"]}')
	# Record the tool results as tool messages.
	outbound_msgs.append(
	  ToolMessage(
	    content=response,
	      name=tool_call["name"],
	      tool_call_id=tool_call["id"],
	  )
	)
      return {"messages": outbound_msgs, "order": order, "finished":
order_placed}
    
    def maybe_route_to_tools(state: OrderState) -> str:
      """Route between chat and tool nodes if a tool call is made."""
      if not (msgs := state.get("messages", [])):
	raise ValueError(f"No messages found when parsing state:
{state}")
    
      msg = msgs[-1]
    
      if state.get("finished", False):
	# When an order is placed, exit the app. The system instruction
	# indicates
	# that the chatbot should say thanks and goodbye at this point,
	# so we can exit
	# cleanly.
	return END
    
      elif hasattr(msg, "tool_calls") and len(msg.tool_calls) > 0:
	# Route to `tools` node for any automated tool calls first.
	if any(
	  tool["name"] in tool_node.tools_by_name.keys() for tool in
msg.tool_calls
	):
	return "tools"
      else:
	return "ordering"
      else:
	return "human"
    
